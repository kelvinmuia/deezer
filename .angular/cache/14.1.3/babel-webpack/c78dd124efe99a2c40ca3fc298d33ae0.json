{"ast":null,"code":"/**\n * @license Angular v14.1.3\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, InjectionToken, Inject, Optional } from '@angular/core';\nimport { LocationStrategy } from '@angular/common';\nimport { Subject } from 'rxjs';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Joins two parts of a URL with a slash if needed.\n *\n * @param start  URL string\n * @param end    URL string\n *\n *\n * @returns The joined URL string.\n */\n\nfunction joinWithSlash(start, end) {\n  if (start.length == 0) {\n    return end;\n  }\n\n  if (end.length == 0) {\n    return start;\n  }\n\n  let slashes = 0;\n\n  if (start.endsWith('/')) {\n    slashes++;\n  }\n\n  if (end.startsWith('/')) {\n    slashes++;\n  }\n\n  if (slashes == 2) {\n    return start + end.substring(1);\n  }\n\n  if (slashes == 1) {\n    return start + end;\n  }\n\n  return start + '/' + end;\n}\n/**\n * Removes a trailing slash from a URL string if needed.\n * Looks for the first occurrence of either `#`, `?`, or the end of the\n * line as `/` characters and removes the trailing slash if one exists.\n *\n * @param url URL string.\n *\n * @returns The URL string, modified if needed.\n */\n\n\nfunction stripTrailingSlash(url) {\n  const match = url.match(/#|\\?|$/);\n  const pathEndIdx = match && match.index || url.length;\n  const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === '/' ? 1 : 0);\n  return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);\n}\n/**\n * Normalizes URL parameters by prepending with `?` if needed.\n *\n * @param  params String of URL parameters.\n *\n * @returns The normalized URL parameters string.\n */\n\n\nfunction normalizeQueryParams(params) {\n  return params && params[0] !== '?' ? '?' + params : params;\n}\n/**\n * A spy for {@link Location} that allows tests to fire simulated location events.\n *\n * @publicApi\n */\n\n\nlet SpyLocation = /*#__PURE__*/(() => {\n  class SpyLocation {\n    constructor() {\n      this.urlChanges = [];\n      this._history = [new LocationState('', '', null)];\n      this._historyIndex = 0;\n      /** @internal */\n\n      this._subject = new EventEmitter();\n      /** @internal */\n\n      this._baseHref = '';\n      /** @internal */\n\n      this._locationStrategy = null;\n      /** @internal */\n\n      this._urlChangeListeners = [];\n      /** @internal */\n\n      this._urlChangeSubscription = null;\n    }\n\n    ngOnDestroy() {\n      this._urlChangeSubscription?.unsubscribe();\n      this._urlChangeListeners = [];\n    }\n\n    setInitialPath(url) {\n      this._history[this._historyIndex].path = url;\n    }\n\n    setBaseHref(url) {\n      this._baseHref = url;\n    }\n\n    path() {\n      return this._history[this._historyIndex].path;\n    }\n\n    getState() {\n      return this._history[this._historyIndex].state;\n    }\n\n    isCurrentPathEqualTo(path, query = '') {\n      const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n      const currPath = this.path().endsWith('/') ? this.path().substring(0, this.path().length - 1) : this.path();\n      return currPath == givenPath + (query.length > 0 ? '?' + query : '');\n    }\n\n    simulateUrlPop(pathname) {\n      this._subject.emit({\n        'url': pathname,\n        'pop': true,\n        'type': 'popstate'\n      });\n    }\n\n    simulateHashChange(pathname) {\n      const path = this.prepareExternalUrl(pathname);\n      this.pushHistory(path, '', null);\n      this.urlChanges.push('hash: ' + pathname); // the browser will automatically fire popstate event before each `hashchange` event, so we need\n      // to simulate it.\n\n      this._subject.emit({\n        'url': pathname,\n        'pop': true,\n        'type': 'popstate'\n      });\n\n      this._subject.emit({\n        'url': pathname,\n        'pop': true,\n        'type': 'hashchange'\n      });\n    }\n\n    prepareExternalUrl(url) {\n      if (url.length > 0 && !url.startsWith('/')) {\n        url = '/' + url;\n      }\n\n      return this._baseHref + url;\n    }\n\n    go(path, query = '', state = null) {\n      path = this.prepareExternalUrl(path);\n      this.pushHistory(path, query, state);\n      const locationState = this._history[this._historyIndex - 1];\n\n      if (locationState.path == path && locationState.query == query) {\n        return;\n      }\n\n      const url = path + (query.length > 0 ? '?' + query : '');\n      this.urlChanges.push(url);\n\n      this._notifyUrlChangeListeners(path + normalizeQueryParams(query), state);\n    }\n\n    replaceState(path, query = '', state = null) {\n      path = this.prepareExternalUrl(path);\n      const history = this._history[this._historyIndex];\n\n      if (history.path == path && history.query == query) {\n        return;\n      }\n\n      history.path = path;\n      history.query = query;\n      history.state = state;\n      const url = path + (query.length > 0 ? '?' + query : '');\n      this.urlChanges.push('replace: ' + url);\n\n      this._notifyUrlChangeListeners(path + normalizeQueryParams(query), state);\n    }\n\n    forward() {\n      if (this._historyIndex < this._history.length - 1) {\n        this._historyIndex++;\n\n        this._subject.emit({\n          'url': this.path(),\n          'state': this.getState(),\n          'pop': true,\n          'type': 'popstate'\n        });\n      }\n    }\n\n    back() {\n      if (this._historyIndex > 0) {\n        this._historyIndex--;\n\n        this._subject.emit({\n          'url': this.path(),\n          'state': this.getState(),\n          'pop': true,\n          'type': 'popstate'\n        });\n      }\n    }\n\n    historyGo(relativePosition = 0) {\n      const nextPageIndex = this._historyIndex + relativePosition;\n\n      if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n        this._historyIndex = nextPageIndex;\n\n        this._subject.emit({\n          'url': this.path(),\n          'state': this.getState(),\n          'pop': true,\n          'type': 'popstate'\n        });\n      }\n    }\n\n    onUrlChange(fn) {\n      this._urlChangeListeners.push(fn);\n\n      if (!this._urlChangeSubscription) {\n        this._urlChangeSubscription = this.subscribe(v => {\n          this._notifyUrlChangeListeners(v.url, v.state);\n        });\n      }\n\n      return () => {\n        const fnIndex = this._urlChangeListeners.indexOf(fn);\n\n        this._urlChangeListeners.splice(fnIndex, 1);\n\n        if (this._urlChangeListeners.length === 0) {\n          this._urlChangeSubscription?.unsubscribe();\n          this._urlChangeSubscription = null;\n        }\n      };\n    }\n    /** @internal */\n\n\n    _notifyUrlChangeListeners(url = '', state) {\n      this._urlChangeListeners.forEach(fn => fn(url, state));\n    }\n\n    subscribe(onNext, onThrow, onReturn) {\n      return this._subject.subscribe({\n        next: onNext,\n        error: onThrow,\n        complete: onReturn\n      });\n    }\n\n    normalize(url) {\n      return null;\n    }\n\n    pushHistory(path, query, state) {\n      if (this._historyIndex > 0) {\n        this._history.splice(this._historyIndex + 1);\n      }\n\n      this._history.push(new LocationState(path, query, state));\n\n      this._historyIndex = this._history.length - 1;\n    }\n\n  }\n\n  SpyLocation.ɵfac = function SpyLocation_Factory(t) {\n    return new (t || SpyLocation)();\n  };\n\n  SpyLocation.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SpyLocation,\n    factory: SpyLocation.ɵfac\n  });\n  return SpyLocation;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass LocationState {\n  constructor(path, query, state) {\n    this.path = path;\n    this.query = query;\n    this.state = state;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A mock implementation of {@link LocationStrategy} that allows tests to fire simulated\n * location events.\n *\n * @publicApi\n */\n\n\nlet MockLocationStrategy = /*#__PURE__*/(() => {\n  class MockLocationStrategy extends LocationStrategy {\n    constructor() {\n      super();\n      this.internalBaseHref = '/';\n      this.internalPath = '/';\n      this.internalTitle = '';\n      this.urlChanges = [];\n      /** @internal */\n\n      this._subject = new EventEmitter();\n      this.stateChanges = [];\n    }\n\n    simulatePopState(url) {\n      this.internalPath = url;\n\n      this._subject.emit(new _MockPopStateEvent(this.path()));\n    }\n\n    path(includeHash = false) {\n      return this.internalPath;\n    }\n\n    prepareExternalUrl(internal) {\n      if (internal.startsWith('/') && this.internalBaseHref.endsWith('/')) {\n        return this.internalBaseHref + internal.substring(1);\n      }\n\n      return this.internalBaseHref + internal;\n    }\n\n    pushState(ctx, title, path, query) {\n      // Add state change to changes array\n      this.stateChanges.push(ctx);\n      this.internalTitle = title;\n      const url = path + (query.length > 0 ? '?' + query : '');\n      this.internalPath = url;\n      const externalUrl = this.prepareExternalUrl(url);\n      this.urlChanges.push(externalUrl);\n    }\n\n    replaceState(ctx, title, path, query) {\n      // Reset the last index of stateChanges to the ctx (state) object\n      this.stateChanges[(this.stateChanges.length || 1) - 1] = ctx;\n      this.internalTitle = title;\n      const url = path + (query.length > 0 ? '?' + query : '');\n      this.internalPath = url;\n      const externalUrl = this.prepareExternalUrl(url);\n      this.urlChanges.push('replace: ' + externalUrl);\n    }\n\n    onPopState(fn) {\n      this._subject.subscribe({\n        next: fn\n      });\n    }\n\n    getBaseHref() {\n      return this.internalBaseHref;\n    }\n\n    back() {\n      if (this.urlChanges.length > 0) {\n        this.urlChanges.pop();\n        this.stateChanges.pop();\n        const nextUrl = this.urlChanges.length > 0 ? this.urlChanges[this.urlChanges.length - 1] : '';\n        this.simulatePopState(nextUrl);\n      }\n    }\n\n    forward() {\n      throw 'not implemented';\n    }\n\n    getState() {\n      return this.stateChanges[(this.stateChanges.length || 1) - 1];\n    }\n\n  }\n\n  MockLocationStrategy.ɵfac = function MockLocationStrategy_Factory(t) {\n    return new (t || MockLocationStrategy)();\n  };\n\n  MockLocationStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MockLocationStrategy,\n    factory: MockLocationStrategy.ɵfac\n  });\n  return MockLocationStrategy;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass _MockPopStateEvent {\n  constructor(newUrl) {\n    this.newUrl = newUrl;\n    this.pop = true;\n    this.type = 'popstate';\n  }\n\n}\n/**\n * Parser from https://tools.ietf.org/html/rfc3986#appendix-B\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n *\n * Example: http://www.ics.uci.edu/pub/ietf/uri/#Related\n *\n * Results in:\n *\n * $1 = http:\n * $2 = http\n * $3 = //www.ics.uci.edu\n * $4 = www.ics.uci.edu\n * $5 = /pub/ietf/uri/\n * $6 = <undefined>\n * $7 = <undefined>\n * $8 = #Related\n * $9 = Related\n */\n\n\nconst urlParse = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\nfunction parseUrl(urlStr, baseHref) {\n  const verifyProtocol = /^((http[s]?|ftp):\\/\\/)/;\n  let serverBase; // URL class requires full URL. If the URL string doesn't start with protocol, we need to add\n  // an arbitrary base URL which can be removed afterward.\n\n  if (!verifyProtocol.test(urlStr)) {\n    serverBase = 'http://empty.com/';\n  }\n\n  let parsedUrl;\n\n  try {\n    parsedUrl = new URL(urlStr, serverBase);\n  } catch (e) {\n    const result = urlParse.exec(serverBase || '' + urlStr);\n\n    if (!result) {\n      throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);\n    }\n\n    const hostSplit = result[4].split(':');\n    parsedUrl = {\n      protocol: result[1],\n      hostname: hostSplit[0],\n      port: hostSplit[1] || '',\n      pathname: result[5],\n      search: result[6],\n      hash: result[8]\n    };\n  }\n\n  if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {\n    parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);\n  }\n\n  return {\n    hostname: !serverBase && parsedUrl.hostname || '',\n    protocol: !serverBase && parsedUrl.protocol || '',\n    port: !serverBase && parsedUrl.port || '',\n    pathname: parsedUrl.pathname || '/',\n    search: parsedUrl.search || '',\n    hash: parsedUrl.hash || ''\n  };\n}\n/**\n * Provider for mock platform location config\n *\n * @publicApi\n */\n\n\nconst MOCK_PLATFORM_LOCATION_CONFIG = /*#__PURE__*/new InjectionToken('MOCK_PLATFORM_LOCATION_CONFIG');\n/**\n * Mock implementation of URL state.\n *\n * @publicApi\n */\n\nlet MockPlatformLocation = /*#__PURE__*/(() => {\n  class MockPlatformLocation {\n    constructor(config) {\n      this.baseHref = '';\n      this.hashUpdate = new Subject();\n      this.urlChangeIndex = 0;\n      this.urlChanges = [{\n        hostname: '',\n        protocol: '',\n        port: '',\n        pathname: '/',\n        search: '',\n        hash: '',\n        state: null\n      }];\n\n      if (config) {\n        this.baseHref = config.appBaseHref || '';\n        const parsedChanges = this.parseChanges(null, config.startUrl || 'http://_empty_/', this.baseHref);\n        this.urlChanges[0] = { ...parsedChanges\n        };\n      }\n    }\n\n    get hostname() {\n      return this.urlChanges[this.urlChangeIndex].hostname;\n    }\n\n    get protocol() {\n      return this.urlChanges[this.urlChangeIndex].protocol;\n    }\n\n    get port() {\n      return this.urlChanges[this.urlChangeIndex].port;\n    }\n\n    get pathname() {\n      return this.urlChanges[this.urlChangeIndex].pathname;\n    }\n\n    get search() {\n      return this.urlChanges[this.urlChangeIndex].search;\n    }\n\n    get hash() {\n      return this.urlChanges[this.urlChangeIndex].hash;\n    }\n\n    get state() {\n      return this.urlChanges[this.urlChangeIndex].state;\n    }\n\n    getBaseHrefFromDOM() {\n      return this.baseHref;\n    }\n\n    onPopState(fn) {\n      // No-op: a state stack is not implemented, so\n      // no events will ever come.\n      return () => {};\n    }\n\n    onHashChange(fn) {\n      const subscription = this.hashUpdate.subscribe(fn);\n      return () => subscription.unsubscribe();\n    }\n\n    get href() {\n      let url = `${this.protocol}//${this.hostname}${this.port ? ':' + this.port : ''}`;\n      url += `${this.pathname === '/' ? '' : this.pathname}${this.search}${this.hash}`;\n      return url;\n    }\n\n    get url() {\n      return `${this.pathname}${this.search}${this.hash}`;\n    }\n\n    parseChanges(state, url, baseHref = '') {\n      // When the `history.state` value is stored, it is always copied.\n      state = JSON.parse(JSON.stringify(state));\n      return { ...parseUrl(url, baseHref),\n        state\n      };\n    }\n\n    replaceState(state, title, newUrl) {\n      const {\n        pathname,\n        search,\n        state: parsedState,\n        hash\n      } = this.parseChanges(state, newUrl);\n      this.urlChanges[this.urlChangeIndex] = { ...this.urlChanges[this.urlChangeIndex],\n        pathname,\n        search,\n        hash,\n        state: parsedState\n      };\n    }\n\n    pushState(state, title, newUrl) {\n      const {\n        pathname,\n        search,\n        state: parsedState,\n        hash\n      } = this.parseChanges(state, newUrl);\n\n      if (this.urlChangeIndex > 0) {\n        this.urlChanges.splice(this.urlChangeIndex + 1);\n      }\n\n      this.urlChanges.push({ ...this.urlChanges[this.urlChangeIndex],\n        pathname,\n        search,\n        hash,\n        state: parsedState\n      });\n      this.urlChangeIndex = this.urlChanges.length - 1;\n    }\n\n    forward() {\n      const oldUrl = this.url;\n      const oldHash = this.hash;\n\n      if (this.urlChangeIndex < this.urlChanges.length) {\n        this.urlChangeIndex++;\n      }\n\n      this.scheduleHashUpdate(oldHash, oldUrl);\n    }\n\n    back() {\n      const oldUrl = this.url;\n      const oldHash = this.hash;\n\n      if (this.urlChangeIndex > 0) {\n        this.urlChangeIndex--;\n      }\n\n      this.scheduleHashUpdate(oldHash, oldUrl);\n    }\n\n    historyGo(relativePosition = 0) {\n      const oldUrl = this.url;\n      const oldHash = this.hash;\n      const nextPageIndex = this.urlChangeIndex + relativePosition;\n\n      if (nextPageIndex >= 0 && nextPageIndex < this.urlChanges.length) {\n        this.urlChangeIndex = nextPageIndex;\n      }\n\n      this.scheduleHashUpdate(oldHash, oldUrl);\n    }\n\n    getState() {\n      return this.state;\n    }\n\n    scheduleHashUpdate(oldHash, oldUrl) {\n      if (oldHash !== this.hash) {\n        scheduleMicroTask(() => this.hashUpdate.next({\n          type: 'hashchange',\n          state: null,\n          oldUrl,\n          newUrl: this.url\n        }));\n      }\n    }\n\n  }\n\n  MockPlatformLocation.ɵfac = function MockPlatformLocation_Factory(t) {\n    return new (t || MockPlatformLocation)(i0.ɵɵinject(MOCK_PLATFORM_LOCATION_CONFIG, 8));\n  };\n\n  MockPlatformLocation.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MockPlatformLocation,\n    factory: MockPlatformLocation.ɵfac\n  });\n  return MockPlatformLocation;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction scheduleMicroTask(cb) {\n  Promise.resolve(null).then(cb);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MOCK_PLATFORM_LOCATION_CONFIG, MockLocationStrategy, MockPlatformLocation, SpyLocation }; //# sourceMappingURL=testing.mjs.map","map":null,"metadata":{},"sourceType":"module"}