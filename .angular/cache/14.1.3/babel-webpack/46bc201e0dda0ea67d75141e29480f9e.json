{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, ComponentFactoryResolver, Directive, Pipe, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { of, from, Subject, BehaviorSubject, forkJoin, combineLatest, EMPTY } from 'rxjs';\nimport { take, map, retry, tap, catchError, shareReplay, switchMap } from 'rxjs/operators';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\n\nclass DefaultLoader {\n  constructor(translations) {\n    this.translations = translations;\n  }\n\n  getTranslation(lang) {\n    return of(this.translations.get(lang) || {});\n  }\n\n}\n\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\nfunction getValue(obj, path) {\n  if (!obj) {\n    return obj;\n  }\n  /* For cases where the key is like: 'general.something.thing' */\n\n\n  if (Object.prototype.hasOwnProperty.call(obj, path)) {\n    return obj[path];\n  }\n\n  return path.split('.').reduce((p, c) => p?.[c], obj);\n}\n\nfunction setValue(obj, prop, val) {\n  obj = { ...obj\n  };\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : { ...acc[part]\n      };\n    }\n\n    return acc && acc[part];\n  }, obj);\n  return obj;\n}\n\nfunction size(collection) {\n  if (!collection) {\n    return 0;\n  }\n\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n\n  return collection ? collection.length : 0;\n}\n\nfunction isEmpty(collection) {\n  return size(collection) === 0;\n}\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\nfunction isObject(item) {\n  return !!item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase()).replace(/\\s+|_|-|\\//g, '');\n}\n\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\nfunction isDefined(value) {\n  return isNil(value) === false;\n}\n\nfunction toNumber(value) {\n  if (isNumber(value)) return value;\n\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n\n  return null;\n}\n\nfunction isScopeObject(item) {\n  return item && typeof item.scope === 'string';\n}\n\nfunction hasInlineLoader(item) {\n  return item && isObject(item.loader);\n}\n\nfunction unflatten(obj) {\n  return unflatten$1(obj);\n}\n\nfunction flatten(obj) {\n  return flatten$1(obj, {\n    safe: true\n  });\n}\n\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory: () => {\n    return {\n      defaultLang: 'en'\n    };\n  }\n});\nconst defaultConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  },\n  interpolation: ['{{', '}}']\n};\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\n\nfunction translocoConfig(config = defaultConfig) {\n  return { ...defaultConfig,\n    ...config\n  };\n}\n\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nlet DefaultTranspiler = /*#__PURE__*/(() => {\n  class DefaultTranspiler {\n    constructor(userConfig) {\n      this.interpolationMatcher = resolveMatcher(userConfig);\n    }\n\n    transpile(value, params = {}, translation) {\n      if (isString(value)) {\n        return value.replace(this.interpolationMatcher, (_, match) => {\n          match = match.trim();\n\n          if (isDefined(params[match])) {\n            return params[match];\n          }\n\n          return isDefined(translation[match]) ? this.transpile(translation[match], params, translation) : '';\n        });\n      } else if (params) {\n        if (isObject(value)) {\n          value = this.handleObject(value, params, translation);\n        } else if (Array.isArray(value)) {\n          value = this.handleArray(value, params, translation);\n        }\n      }\n\n      return value;\n    }\n    /**\n     *\n     * @example\n     *\n     * const en = {\n     *  a: {\n     *    b: {\n     *      c: \"Hello {{ value }}\"\n     *    }\n     *  }\n     * }\n     *\n     * const params =  {\n     *  \"b.c\": { value: \"Transloco \"}\n     * }\n     *\n     * service.selectTranslate('a', params);\n     *\n     * // the first param will be the result of `en.a`.\n     * // the second param will be `params`.\n     * parser.transpile(value, params, {});\n     *\n     *\n     */\n\n\n    handleObject(value, params = {}, translation) {\n      let result = value;\n      Object.keys(params).forEach(p => {\n        // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n        const v = getValue(result, p); // get the params of \"b.c\" => { value: \"Transloco\" }\n\n        const getParams = getValue(params, p); // transpile the value => \"Hello Transloco\"\n\n        const transpiled = this.transpile(v, getParams, translation); // set \"b.c\" to `transpiled`\n\n        result = setValue(result, p, transpiled);\n      });\n      return result;\n    }\n\n    handleArray(value, params = {}, translation) {\n      return value.map(v => this.transpile(v, params, translation));\n    }\n\n  }\n\n  DefaultTranspiler.ɵfac = function DefaultTranspiler_Factory(t) {\n    return new (t || DefaultTranspiler)(i0.ɵɵinject(TRANSLOCO_CONFIG, 8));\n  };\n\n  DefaultTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultTranspiler,\n    factory: DefaultTranspiler.ɵfac\n  });\n  return DefaultTranspiler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction resolveMatcher(userConfig) {\n  const [start, end] = userConfig && userConfig.interpolation ? userConfig.interpolation : defaultConfig.interpolation;\n  return new RegExp(`${start}(.*?)${end}`, 'g');\n}\n\nfunction getFunctionArgs(argsString) {\n  const splitted = argsString ? argsString.split(',') : [];\n  const args = [];\n\n  for (let i = 0; i < splitted.length; i++) {\n    let value = splitted[i].trim();\n\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n\n    args.push(value);\n  }\n\n  return args;\n}\n\nlet FunctionalTranspiler = /*#__PURE__*/(() => {\n  class FunctionalTranspiler extends DefaultTranspiler {\n    constructor(injector) {\n      super();\n      this.injector = injector;\n    }\n\n    transpile(value, params = {}, translation) {\n      let transpiled = value;\n\n      if (isString(value)) {\n        transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g, (match, functionName, args) => {\n          try {\n            const func = this.injector.get(functionName);\n            return func.transpile(...getFunctionArgs(args));\n          } catch (e) {\n            let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n\n            if (e.message.includes('NullInjectorError')) {\n              message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n            }\n\n            throw new Error(message);\n          }\n        });\n      }\n\n      return super.transpile(transpiled, params, translation);\n    }\n\n  }\n\n  FunctionalTranspiler.ɵfac = function FunctionalTranspiler_Factory(t) {\n    return new (t || FunctionalTranspiler)(i0.ɵɵinject(i0.Injector));\n  };\n\n  FunctionalTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FunctionalTranspiler,\n    factory: FunctionalTranspiler.ɵfac\n  });\n  return FunctionalTranspiler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nlet DefaultHandler = /*#__PURE__*/(() => {\n  class DefaultHandler {\n    handle(key, config) {\n      if (config.missingHandler.logMissingKey && !config.prodMode) {\n        const msg = `Missing translation for '${key}'`;\n        console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n      }\n\n      return key;\n    }\n\n  }\n\n  DefaultHandler.ɵfac = function DefaultHandler_Factory(t) {\n    return new (t || DefaultHandler)();\n  };\n\n  DefaultHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultHandler,\n    factory: DefaultHandler.ɵfac\n  });\n  return DefaultHandler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nlet DefaultInterceptor = /*#__PURE__*/(() => {\n  class DefaultInterceptor {\n    preSaveTranslation(translation) {\n      return translation;\n    }\n\n    preSaveTranslationKey(_, value) {\n      return value;\n    }\n\n  }\n\n  DefaultInterceptor.ɵfac = function DefaultInterceptor_Factory(t) {\n    return new (t || DefaultInterceptor)();\n  };\n\n  DefaultInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultInterceptor,\n    factory: DefaultInterceptor.ɵfac\n  });\n  return DefaultInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nlet DefaultFallbackStrategy = /*#__PURE__*/(() => {\n  class DefaultFallbackStrategy {\n    constructor(userConfig) {\n      this.userConfig = userConfig;\n    }\n\n    getNextLangs() {\n      const fallbackLang = this.userConfig.fallbackLang;\n\n      if (!fallbackLang) {\n        throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n      }\n\n      return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n    }\n\n  }\n\n  DefaultFallbackStrategy.ɵfac = function DefaultFallbackStrategy_Factory(t) {\n    return new (t || DefaultFallbackStrategy)(i0.ɵɵinject(TRANSLOCO_CONFIG));\n  };\n\n  DefaultFallbackStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultFallbackStrategy,\n    factory: DefaultFallbackStrategy.ɵfac\n  });\n  return DefaultFallbackStrategy;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction mergeConfig(defaultConfig, userConfig) {\n  return { ...defaultConfig,\n    ...userConfig,\n    missingHandler: { ...defaultConfig.missingHandler,\n      ...userConfig.missingHandler\n    },\n    flatten: { ...defaultConfig.flatten,\n      ...userConfig.flatten\n    }\n  };\n}\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\n\n\nfunction getScopeFromLang(lang) {\n  if (!lang) {\n    return '';\n  }\n\n  const split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\n\n\nfunction getLangFromScope(lang) {\n  if (!lang) {\n    return '';\n  }\n\n  return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\n\n\nfunction getPipeValue(str, value, char = '|') {\n  if (isString(str)) {\n    const splitted = str.split(char);\n    const lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n\n  return [false, ''];\n}\n\nfunction shouldListenToLangChanges(service, lang) {\n  const [hasStatic] = getPipeValue(lang, 'static');\n\n  if (!hasStatic) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return !!service.config.reRenderOnLangChange;\n  } // We have 'lang|static' so don't listen to lang changes\n\n\n  return false;\n}\n\nfunction listenOrNotOperator(listenToLangChange) {\n  return listenToLangChange ? source => source : take(1);\n}\n\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce((acc, lang) => {\n    acc[`${scope}/${lang}`] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\n\nfunction resolveInlineLoader(providerScope, scope) {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : undefined;\n}\n\nfunction getEventPayload(lang) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang)\n  };\n}\n\nfunction resolveLoader(options) {\n  const {\n    path,\n    inlineLoader,\n    mainLoader,\n    data\n  } = options;\n\n  if (inlineLoader) {\n    const pathLoader = inlineLoader[path];\n\n    if (isFunction(pathLoader) === false) {\n      throw `You're using an inline loader but didn't provide a loader for ${path}`;\n    }\n\n    return inlineLoader[path]().then(res => res.default ? res.default : res);\n  }\n\n  return mainLoader.getTranslation(path, data);\n}\n\nfunction getFallbacksLoaders({\n  mainLoader,\n  path,\n  data,\n  fallbackPath,\n  inlineLoader\n}) {\n  const paths = fallbackPath ? [path, fallbackPath] : [path];\n  return paths.map(path => {\n    const loader = resolveLoader({\n      path,\n      mainLoader,\n      inlineLoader,\n      data\n    });\n    return from(loader).pipe(map(translation => ({\n      translation,\n      lang: path\n    })));\n  });\n}\n\nlet service;\n\nfunction translate(key, params = {}, lang) {\n  return service.translate(key, params, lang);\n}\n\nfunction translateObject(key, params = {}, lang) {\n  return service.translateObject(key, params, lang);\n}\n\nlet TranslocoService = /*#__PURE__*/(() => {\n  class TranslocoService {\n    constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n      this.loader = loader;\n      this.parser = parser;\n      this.missingHandler = missingHandler;\n      this.interceptor = interceptor;\n      this.userConfig = userConfig;\n      this.fallbackStrategy = fallbackStrategy;\n      this.subscription = null;\n      this.translations = new Map();\n      this.cache = new Map();\n      this.defaultLang = '';\n      this.availableLangs = [];\n      this.isResolvedMissingOnce = false;\n      this.failedLangs = new Set();\n      this.events = new Subject();\n      this.events$ = this.events.asObservable();\n\n      if (!this.loader) {\n        this.loader = new DefaultLoader(this.translations);\n      }\n\n      service = this;\n      this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);\n      this.setAvailableLangs(this.mergedConfig.availableLangs || []);\n      this.setFallbackLangForMissingTranslation(this.mergedConfig);\n      this.setDefaultLang(this.mergedConfig.defaultLang);\n      this.lang = new BehaviorSubject(this.getDefaultLang()); // Don't use distinctUntilChanged as we need the ability to update\n      // the value when using setTranslation or setTranslationKeys\n\n      this.langChanges$ = this.lang.asObservable();\n      /**\n       * When we have a failure, we want to define the next language that succeeded as the active\n       */\n\n      this.subscription = this.events$.subscribe(e => {\n        if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n          this.setActiveLang(e.payload.langName);\n        }\n      });\n    }\n\n    get config() {\n      return this.mergedConfig;\n    }\n\n    getDefaultLang() {\n      return this.defaultLang;\n    }\n\n    setDefaultLang(lang) {\n      this.defaultLang = lang;\n    }\n\n    getActiveLang() {\n      return this.lang.getValue();\n    }\n\n    setActiveLang(lang) {\n      this.lang.next(lang);\n      this.parser.onLangChanged?.(lang);\n      this.events.next({\n        type: 'langChanged',\n        payload: getEventPayload(lang)\n      });\n      return this;\n    }\n\n    setAvailableLangs(langs) {\n      this.availableLangs = langs;\n    }\n    /**\n     * Gets the available languages.\n     *\n     * @returns\n     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n     * depending on how the available languages are set in your module.\n     */\n\n\n    getAvailableLangs() {\n      return this.availableLangs;\n    }\n\n    load(path, options = {}) {\n      const cached = this.cache.get(path);\n\n      if (cached) {\n        return cached;\n      }\n\n      let loadTranslation;\n\n      const isScope = this._isLangScoped(path);\n\n      let scope;\n\n      if (isScope) {\n        scope = getScopeFromLang(path);\n      }\n\n      const loadersOptions = {\n        path,\n        mainLoader: this.loader,\n        inlineLoader: options.inlineLoader,\n        data: isScope ? {\n          scope: scope\n        } : undefined\n      };\n\n      if (this.useFallbackTranslation(path)) {\n        // if the path is scope the fallback should be `scope/fallbackLang`;\n        const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;\n        const loaders = getFallbacksLoaders({ ...loadersOptions,\n          fallbackPath: fallback\n        });\n        loadTranslation = forkJoin(loaders);\n      } else {\n        const loader = resolveLoader(loadersOptions);\n        loadTranslation = from(loader);\n      }\n\n      const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap(translation => {\n        if (Array.isArray(translation)) {\n          translation.forEach(t => {\n            this.handleSuccess(t.lang, t.translation); // Save the fallback in cache so we'll not create a redundant request\n\n            if (t.lang !== path) {\n              this.cache.set(t.lang, of({}));\n            }\n          });\n          return;\n        }\n\n        this.handleSuccess(path, translation);\n      }), catchError(error => {\n        if (!this.mergedConfig.prodMode) {\n          console.error(`Error while trying to load \"${path}\"`, error);\n        }\n\n        return this.handleFailure(path, options);\n      }), shareReplay(1));\n      this.cache.set(path, load$);\n      return load$;\n    }\n    /**\n     * Gets the instant translated value of a key\n     *\n     * @example\n     *\n     * translate<string>('hello')\n     * translate('hello', { value: 'value' })\n     * translate<string[]>(['hello', 'key'])\n     * translate('hello', { }, 'en')\n     * translate('scope.someKey', { }, 'en')\n     */\n\n\n    translate(key, params = {}, lang = this.getActiveLang()) {\n      if (!key) return key;\n      const {\n        scope,\n        resolveLang\n      } = this.resolveLangAndScope(lang);\n\n      if (Array.isArray(key)) {\n        return key.map(k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n      }\n\n      key = scope ? `${scope}.${key}` : key;\n      const translation = this.getTranslation(resolveLang);\n      const value = translation[key];\n\n      if (!value) {\n        return this._handleMissingKey(key, value, params);\n      }\n\n      return this.parser.transpile(value, params, translation);\n    }\n    /**\n     * Gets the translated value of a key as observable\n     *\n     * @example\n     *\n     * selectTranslate<string>('hello').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n     *\n     */\n\n\n    selectTranslate(key, params, lang, _isObject = false) {\n      let inlineLoader;\n\n      const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang)));\n\n      if (isNil(lang)) {\n        return this.langChanges$.pipe(switchMap(lang => load(lang)));\n      }\n\n      if (isScopeObject(lang)) {\n        // it's a scope object.\n        const providerScope = lang;\n        lang = providerScope.scope;\n        inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n      }\n\n      lang = lang;\n\n      if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n        return load(lang);\n      } // it's a scope\n\n\n      const scope = lang;\n      return this.langChanges$.pipe(switchMap(lang => load(`${scope}/${lang}`, {\n        inlineLoader\n      })));\n    }\n    /**\n     * Whether the scope with lang\n     *\n     * @example\n     *\n     * todos/en => true\n     * todos => false\n     */\n\n\n    isScopeWithLang(lang) {\n      return this.isLang(getLangFromScope(lang));\n    }\n\n    translateObject(key, params = {}, lang = this.getActiveLang()) {\n      if (isString(key) || Array.isArray(key)) {\n        const {\n          resolveLang,\n          scope\n        } = this.resolveLangAndScope(lang);\n\n        if (Array.isArray(key)) {\n          return key.map(k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n        }\n\n        const translation = this.getTranslation(resolveLang);\n        key = scope ? `${scope}.${key}` : key;\n        const value = unflatten(this.getObjectByKey(translation, key));\n        /* If an empty object was returned we want to try and translate the key as a string and not an object */\n\n        return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);\n      }\n\n      const translations = [];\n\n      for (const [_key, _params] of this.getEntries(key)) {\n        translations.push(this.translateObject(_key, _params, lang));\n      }\n\n      return translations;\n    }\n\n    selectTranslateObject(key, params, lang) {\n      if (isString(key) || Array.isArray(key)) {\n        return this.selectTranslate(key, params, lang, true);\n      }\n\n      const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n      /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n       * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n\n      return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map(value => {\n        const translations = [value];\n\n        for (const [_key, _params] of rest) {\n          translations.push(this.translateObject(_key, _params, lang));\n        }\n\n        return translations;\n      }));\n    }\n\n    getTranslation(langOrScope) {\n      if (langOrScope) {\n        if (this.isLang(langOrScope)) {\n          return this.translations.get(langOrScope) || {};\n        } else {\n          // This is a scope, build the scope value from the translation object\n          const {\n            scope,\n            resolveLang\n          } = this.resolveLangAndScope(langOrScope);\n          const translation = this.translations.get(resolveLang) || {};\n          return this.getObjectByKey(translation, scope);\n        }\n      }\n\n      return this.translations;\n    }\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * selectTranslation().subscribe() - will return the current lang translation\n     * selectTranslation('es').subscribe()\n     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n     * selectTranslation('admin-page/es').subscribe()\n     */\n\n\n    selectTranslation(lang) {\n      let language$ = this.langChanges$;\n\n      if (lang) {\n        const scopeLangSpecified = getLangFromScope(lang) !== lang;\n\n        if (this.isLang(lang) || scopeLangSpecified) {\n          language$ = of(lang);\n        } else {\n          language$ = this.langChanges$.pipe(map(currentLang => `${lang}/${currentLang}`));\n        }\n      }\n\n      return language$.pipe(switchMap(language => this.load(language).pipe(map(() => this.getTranslation(language)))));\n    }\n    /**\n     * Sets or merge a given translation object to current lang\n     *\n     * @example\n     *\n     * setTranslation({ ... })\n     * setTranslation({ ... }, 'en')\n     * setTranslation({ ... }, 'es', { merge: false } )\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\n     */\n\n\n    setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n      const defaults = {\n        merge: true,\n        emitChange: true\n      };\n      const mergedOptions = { ...defaults,\n        ...options\n      };\n      const scope = getScopeFromLang(lang);\n      /**\n       * If this isn't a scope we use the whole translation as is\n       * otherwise we need to flat the scope and use it\n       */\n\n      let flattenScopeOrTranslation = translation; // Merged the scoped language into the active language\n\n      if (scope) {\n        const key = this.getMappedScope(scope);\n        flattenScopeOrTranslation = flatten({\n          [key]: translation\n        });\n      }\n\n      const currentLang = scope ? getLangFromScope(lang) : lang;\n      const mergedTranslation = { ...(mergedOptions.merge && this.getTranslation(currentLang)),\n        ...flattenScopeOrTranslation\n      };\n      const flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n      const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n      this.translations.set(currentLang, withHook);\n      mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n    }\n    /**\n     * Sets translation key with given value\n     *\n     * @example\n     *\n     * setTranslationKey('key', 'value')\n     * setTranslationKey('key.nested', 'value')\n     * setTranslationKey('key.nested', 'value', 'en')\n     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n     */\n\n\n    setTranslationKey(key, value, // Todo: Add the lang to the options in v3\n    lang = this.getActiveLang(), options = {}) {\n      const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n      const newValue = {\n        [key]: withHook\n      };\n      this.setTranslation(newValue, lang, { ...options,\n        merge: true\n      });\n    }\n    /**\n     * Sets the fallback lang for the currently active language\n     * @param fallbackLang\n     */\n\n\n    setFallbackLangForMissingTranslation({\n      fallbackLang\n    }) {\n      const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n\n      if (fallbackLang && this.useFallbackTranslation(lang)) {\n        this.firstFallbackLang = lang;\n      }\n    }\n    /**\n     * @internal\n     */\n\n\n    _handleMissingKey(key, value, params) {\n      if (this.config.missingHandler.allowEmpty && value === '') {\n        return '';\n      }\n\n      if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n        // We need to set it to true to prevent a loop\n        this.isResolvedMissingOnce = true;\n        const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n        this.isResolvedMissingOnce = false;\n        return fallbackValue;\n      }\n\n      return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n    }\n    /**\n     * @internal\n     */\n\n\n    _isLangScoped(lang) {\n      return this.getAvailableLangsIds().indexOf(lang) === -1;\n    }\n    /**\n     * Checks if a given string is one of the specified available languages.\n     * @returns\n     * True if the given string is an available language.\n     * False if the given string is not an available language.\n     */\n\n\n    isLang(lang) {\n      return this.getAvailableLangsIds().indexOf(lang) !== -1;\n    }\n    /**\n     * @internal\n     *\n     * We always want to make sure the global lang is loaded\n     * before loading the scope since you can access both via the pipe/directive.\n     */\n\n\n    _loadDependencies(path, inlineLoader) {\n      const mainLang = getLangFromScope(path);\n\n      if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n        return combineLatest(this.load(mainLang), this.load(path, {\n          inlineLoader\n        }));\n      }\n\n      return this.load(path, {\n        inlineLoader\n      });\n    }\n    /**\n     * @internal\n     */\n\n\n    _completeScopeWithLang(langOrScope) {\n      if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n        return `${langOrScope}/${this.getActiveLang()}`;\n      }\n\n      return langOrScope;\n    }\n    /**\n     * @internal\n     */\n\n\n    _setScopeAlias(scope, alias) {\n      if (!this.mergedConfig.scopeMapping) {\n        this.mergedConfig.scopeMapping = {};\n      }\n\n      this.mergedConfig.scopeMapping[scope] = alias;\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n        // callback within its `destination` property, preventing classes from being GC'd.\n\n        this.subscription = null;\n      } // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n      // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n      // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n      // and destroyed per each HTTP request, but any service is not getting GC'd.\n\n\n      this.cache.clear();\n    }\n\n    isLoadedTranslation(lang) {\n      return size(this.getTranslation(lang));\n    }\n\n    getAvailableLangsIds() {\n      const first = this.getAvailableLangs()[0];\n\n      if (isString(first)) {\n        return this.getAvailableLangs();\n      }\n\n      return this.getAvailableLangs().map(l => l.id);\n    }\n\n    getMissingHandlerData() {\n      return { ...this.config,\n        activeLang: this.getActiveLang(),\n        availableLangs: this.availableLangs,\n        defaultLang: this.defaultLang\n      };\n    }\n    /**\n     * Use a fallback translation set for missing keys of the primary language\n     * This is unrelated to the fallback language (which changes the active language)\n     */\n\n\n    useFallbackTranslation(lang) {\n      return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n    }\n\n    handleSuccess(lang, translation) {\n      this.setTranslation(translation, lang, {\n        emitChange: false\n      });\n      this.events.next({\n        wasFailure: !!this.failedLangs.size,\n        type: 'translationLoadSuccess',\n        payload: getEventPayload(lang)\n      });\n      this.failedLangs.forEach(l => this.cache.delete(l));\n      this.failedLangs.clear();\n    }\n\n    handleFailure(lang, loadOptions) {\n      // When starting to load a first choice language, initialize\n      // the failed counter and resolve the fallback langs.\n      if (isNil(loadOptions.failedCounter)) {\n        loadOptions.failedCounter = 0;\n\n        if (!loadOptions.fallbackLangs) {\n          loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n        }\n      }\n\n      const splitted = lang.split('/');\n      const fallbacks = loadOptions.fallbackLangs;\n      const nextLang = fallbacks[loadOptions.failedCounter];\n      this.failedLangs.add(lang); // This handles the case where a loaded fallback language is requested again\n\n      if (this.cache.has(nextLang)) {\n        this.handleSuccess(nextLang, this.getTranslation(nextLang));\n        return EMPTY;\n      }\n\n      const isFallbackLang = nextLang === splitted[splitted.length - 1];\n\n      if (!nextLang || isFallbackLang) {\n        let msg = `Unable to load translation and all the fallback languages`;\n\n        if (splitted.length > 1) {\n          msg += `, did you misspelled the scope name?`;\n        }\n\n        throw new Error(msg);\n      }\n\n      let resolveLang = nextLang; // if it's scoped lang\n\n      if (splitted.length > 1) {\n        // We need to resolve it to:\n        // todos/langNotExists => todos/nextLang\n        splitted[splitted.length - 1] = nextLang;\n        resolveLang = splitted.join('/');\n      }\n\n      loadOptions.failedCounter++;\n      this.events.next({\n        type: 'translationLoadFailure',\n        payload: getEventPayload(lang)\n      });\n      return this.load(resolveLang, loadOptions);\n    }\n\n    getMappedScope(scope) {\n      const {\n        scopeMapping = {}\n      } = this.config;\n      return scopeMapping[scope] || toCamelCase(scope);\n    }\n    /**\n     * If lang is scope we need to check the following cases:\n     * todos/es => in this case we should take `es` as lang\n     * todos => in this case we should set the active lang as lang\n     */\n\n\n    resolveLangAndScope(lang) {\n      let resolveLang = lang;\n      let scope;\n\n      if (this._isLangScoped(lang)) {\n        // en for example\n        const langFromScope = getLangFromScope(lang); // en is lang\n\n        const hasLang = this.isLang(langFromScope); // take en\n\n        resolveLang = hasLang ? langFromScope : this.getActiveLang(); // find the scope\n\n        scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n      }\n\n      return {\n        scope,\n        resolveLang\n      };\n    }\n\n    getObjectByKey(translation, key) {\n      const result = {};\n      const prefix = `${key}.`;\n\n      for (const currentKey in translation) {\n        if (currentKey.startsWith(prefix)) {\n          result[currentKey.replace(prefix, '')] = translation[currentKey];\n        }\n      }\n\n      return result;\n    }\n\n    getEntries(key) {\n      return key instanceof Map ? key.entries() : Object.entries(key);\n    }\n\n  }\n\n  TranslocoService.ɵfac = function TranslocoService_Factory(t) {\n    return new (t || TranslocoService)(i0.ɵɵinject(TRANSLOCO_LOADER, 8), i0.ɵɵinject(TRANSLOCO_TRANSPILER), i0.ɵɵinject(TRANSLOCO_MISSING_HANDLER), i0.ɵɵinject(TRANSLOCO_INTERCEPTOR), i0.ɵɵinject(TRANSLOCO_CONFIG), i0.ɵɵinject(TRANSLOCO_FALLBACK_STRATEGY));\n  };\n\n  TranslocoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TranslocoService,\n    factory: TranslocoService.ɵfac,\n    providedIn: 'root'\n  });\n  return TranslocoService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TranslocoLoaderComponent = /*#__PURE__*/(() => {\n  class TranslocoLoaderComponent {}\n\n  TranslocoLoaderComponent.ɵfac = function TranslocoLoaderComponent_Factory(t) {\n    return new (t || TranslocoLoaderComponent)();\n  };\n\n  TranslocoLoaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TranslocoLoaderComponent,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      html: \"html\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[1, \"transloco-loader-template\", 3, \"innerHTML\"]],\n    template: function TranslocoLoaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", ctx.html, i0.ɵɵsanitizeHtml);\n      }\n    },\n    encapsulation: 2\n  });\n  return TranslocoLoaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass TemplateHandler {\n  constructor(view, vcr) {\n    this.view = view;\n    this.vcr = vcr;\n    this.injector = this.vcr.injector;\n  }\n\n  attachView() {\n    if (this.view instanceof TemplateRef) {\n      this.vcr.createEmbeddedView(this.view);\n    } else if (isString(this.view)) {\n      const componentRef = this.createComponent(TranslocoLoaderComponent);\n      componentRef.instance.html = this.view;\n      componentRef.hostView.detectChanges();\n    } else {\n      this.createComponent(this.view);\n    }\n  }\n\n  detachView() {\n    this.vcr.clear();\n  }\n\n  createComponent(cmp) {\n    const cfr = this.injector.get(ComponentFactoryResolver);\n    const factory = cfr.resolveComponentFactory(cmp);\n    return this.vcr.createComponent(factory);\n  }\n\n}\n\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\nclass LangResolver {\n  constructor() {\n    this.initialized = false;\n  } // inline => provider => active\n\n\n  resolve({\n    inline,\n    provider,\n    active\n  }) {\n    let lang = active;\n    /**\n     * When the user changes the lang we need to update\n     * the view. Otherwise, the lang will remain the inline/provided lang\n     */\n\n    if (this.initialized) {\n      lang = active;\n      return lang;\n    }\n\n    if (provider) {\n      const [, extracted] = getPipeValue(provider, 'static');\n      lang = extracted;\n    }\n\n    if (inline) {\n      const [, extracted] = getPipeValue(inline, 'static');\n      lang = extracted;\n    }\n\n    this.initialized = true;\n    return lang;\n  }\n  /**\n   *\n   * Resolve the lang\n   *\n   * @example\n   *\n   * resolveLangBasedOnScope('todos/en') => en\n   * resolveLangBasedOnScope('en') => en\n   *\n   */\n\n\n  resolveLangBasedOnScope(lang) {\n    const scope = getScopeFromLang(lang);\n    return scope ? getLangFromScope(lang) : lang;\n  }\n  /**\n   *\n   * Resolve the lang path for loading\n   *\n   * @example\n   *\n   * resolveLangPath('todos', 'en') => todos/en\n   * resolveLangPath('en') => en\n   *\n   */\n\n\n  resolveLangPath(lang, scope) {\n    return scope ? `${scope}/${lang}` : lang;\n  }\n\n}\n\nclass ScopeResolver {\n  constructor(translocoService) {\n    this.translocoService = translocoService;\n  } // inline => provider\n\n\n  resolve({\n    inline,\n    provider\n  } = {\n    inline: undefined,\n    provider: undefined\n  }) {\n    if (inline) {\n      return inline;\n    }\n\n    if (provider) {\n      if (isScopeObject(provider)) {\n        const {\n          scope,\n          alias = toCamelCase(scope)\n        } = provider;\n\n        this.translocoService._setScopeAlias(scope, alias);\n\n        return scope;\n      }\n\n      return provider;\n    }\n\n    return undefined;\n  }\n\n}\n\nlet TranslocoDirective = /*#__PURE__*/(() => {\n  class TranslocoDirective {\n    constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host, renderer) {\n      this.translocoService = translocoService;\n      this.tpl = tpl;\n      this.providerScope = providerScope;\n      this.providerLang = providerLang;\n      this.providedLoadingTpl = providedLoadingTpl;\n      this.vcr = vcr;\n      this.cdr = cdr;\n      this.host = host;\n      this.renderer = renderer;\n      this.subscription = null;\n      this.translationMemo = {};\n      this.params = {}; // Whether we already rendered the view once\n\n      this.initialized = false;\n      this.langResolver = new LangResolver();\n      this.scopeResolver = new ScopeResolver(this.translocoService);\n      this.strategy = this.tpl === null ? 'attribute' : 'structural';\n    }\n\n    static ngTemplateContextGuard(dir, ctx) {\n      return true;\n    }\n\n    ngOnInit() {\n      const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n      this.subscription = this.translocoService.langChanges$.pipe(switchMap(activeLang => {\n        const lang = this.langResolver.resolve({\n          inline: this.inlineLang,\n          provider: this.providerLang,\n          active: activeLang\n        });\n        return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n      }), listenOrNotOperator(listenToLangChange)).subscribe(() => {\n        this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.strategy === 'attribute' ? this.attributeStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n        this.cdr.markForCheck();\n        this.initialized = true;\n      });\n      const loadingTpl = this.getLoadingTpl();\n\n      if (!this.initialized && loadingTpl) {\n        this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n        this.loaderTplHandler.attachView();\n      }\n    }\n\n    ngOnChanges(changes) {\n      // We need to support dynamic keys/params, so if this is not the first change CD cycle\n      // we need to run the function again in order to update the value\n      if (this.strategy === 'attribute') {\n        const notInit = Object.keys(changes).some(v => !changes[v].firstChange);\n        notInit && this.attributeStrategy();\n      }\n    }\n\n    attributeStrategy() {\n      this.detachLoader();\n      this.renderer.setProperty(this.host.nativeElement, 'innerText', this.translocoService.translate(this.key, this.params, this.currentLang));\n    }\n\n    structuralStrategy(lang, read) {\n      this.translationMemo = {};\n\n      if (this.view) {\n        // when the lang changes we need to change the reference so Angular will update the view\n        this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n        this.view.context['currentLang'] = this.currentLang;\n      } else {\n        this.detachLoader();\n        this.view = this.vcr.createEmbeddedView(this.tpl, {\n          $implicit: this.getTranslateFn(lang, read),\n          currentLang: this.currentLang\n        });\n      }\n    }\n\n    getTranslateFn(lang, read) {\n      return (key, params) => {\n        const withRead = read ? `${read}.${key}` : key;\n        const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n\n        if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n          return this.translationMemo[withParams].value;\n        }\n\n        this.translationMemo[withParams] = {\n          params,\n          value: this.translocoService.translate(withRead, params, lang)\n        };\n        return this.translationMemo[withParams].value;\n      };\n    }\n\n    getLoadingTpl() {\n      return this.inlineTpl || this.providedLoadingTpl;\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n        // callback within its `destination` property, preventing classes from being GC'd.\n\n        this.subscription = null;\n      }\n    }\n\n    detachLoader() {\n      this.loaderTplHandler?.detachView();\n    }\n\n    resolveScope(lang, providerScope) {\n      const resolvedScope = this.scopeResolver.resolve({\n        inline: this.inlineScope,\n        provider: providerScope\n      });\n      this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n      const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n      return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n\n  }\n\n  TranslocoDirective.ɵfac = function TranslocoDirective_Factory(t) {\n    return new (t || TranslocoDirective)(i0.ɵɵdirectiveInject(TranslocoService), i0.ɵɵdirectiveInject(i0.TemplateRef, 8), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LOADING_TEMPLATE, 8), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  TranslocoDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TranslocoDirective,\n    selectors: [[\"\", \"transloco\", \"\"]],\n    inputs: {\n      key: [\"transloco\", \"key\"],\n      params: [\"translocoParams\", \"params\"],\n      inlineScope: [\"translocoScope\", \"inlineScope\"],\n      inlineRead: [\"translocoRead\", \"inlineRead\"],\n      inlineLang: [\"translocoLang\", \"inlineLang\"],\n      inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TranslocoDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TranslocoPipe = /*#__PURE__*/(() => {\n  class TranslocoPipe {\n    constructor(translocoService, providerScope, providerLang, cdr) {\n      this.translocoService = translocoService;\n      this.providerScope = providerScope;\n      this.providerLang = providerLang;\n      this.cdr = cdr;\n      this.subscription = null;\n      this.lastValue = '';\n      this.langResolver = new LangResolver();\n      this.scopeResolver = new ScopeResolver(this.translocoService);\n    } // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n\n\n    transform(key, params, inlineLang) {\n      if (!key) {\n        return key;\n      }\n\n      const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n\n      if (keyName === this.lastKey) {\n        return this.lastValue;\n      }\n\n      this.lastKey = keyName;\n      this.subscription?.unsubscribe();\n      const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);\n      this.subscription = this.translocoService.langChanges$.pipe(switchMap(activeLang => {\n        const lang = this.langResolver.resolve({\n          inline: inlineLang,\n          provider: this.providerLang,\n          active: activeLang\n        });\n        return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n      }), listenOrNotOperator(listenToLangChange)).subscribe(() => this.updateValue(key, params));\n      return this.lastValue;\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n        // callback within its `destination` property, preventing classes from being GC'd.\n\n        this.subscription = null;\n      }\n    }\n\n    updateValue(key, params) {\n      const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n      this.lastValue = this.translocoService.translate(key, params, lang);\n      this.cdr.markForCheck();\n    }\n\n    resolveScope(lang, providerScope) {\n      const resolvedScope = this.scopeResolver.resolve({\n        inline: undefined,\n        provider: providerScope\n      });\n      this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n      const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n      return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n\n  }\n\n  TranslocoPipe.ɵfac = function TranslocoPipe_Factory(t) {\n    return new (t || TranslocoPipe)(i0.ɵɵdirectiveInject(TranslocoService, 16), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 24), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 24), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n  };\n\n  TranslocoPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"transloco\",\n    type: TranslocoPipe,\n    pure: false\n  });\n  return TranslocoPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst defaultProviders = [{\n  provide: TRANSLOCO_TRANSPILER,\n  useClass: DefaultTranspiler,\n  deps: [TRANSLOCO_CONFIG]\n}, {\n  provide: TRANSLOCO_MISSING_HANDLER,\n  useClass: DefaultHandler\n}, {\n  provide: TRANSLOCO_INTERCEPTOR,\n  useClass: DefaultInterceptor\n}, {\n  provide: TRANSLOCO_FALLBACK_STRATEGY,\n  useClass: DefaultFallbackStrategy,\n  deps: [TRANSLOCO_CONFIG]\n}];\nlet TranslocoModule = /*#__PURE__*/(() => {\n  class TranslocoModule {}\n\n  TranslocoModule.ɵfac = function TranslocoModule_Factory(t) {\n    return new (t || TranslocoModule)();\n  };\n\n  TranslocoModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TranslocoModule\n  });\n  TranslocoModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [defaultProviders]\n  });\n  return TranslocoModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nlet TestingLoader = /*#__PURE__*/(() => {\n  class TestingLoader {\n    constructor(langs) {\n      this.langs = langs;\n    }\n\n    getTranslation(lang) {\n      return of(this.langs[lang]);\n    }\n\n  }\n\n  TestingLoader.ɵfac = function TestingLoader_Factory(t) {\n    return new (t || TestingLoader)(i0.ɵɵinject(TRANSLOCO_TEST_LANGS));\n  };\n\n  TestingLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TestingLoader,\n    factory: TestingLoader.ɵfac\n  });\n  return TestingLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction initTranslocoService(service, langs = {}, options) {\n  const preloadAllLangs = () => options.preloadLangs ? Promise.all(Object.keys(langs).map(lang => service.load(lang).toPromise())) : Promise.resolve();\n\n  return preloadAllLangs;\n}\n\nlet TranslocoTestingModule = /*#__PURE__*/(() => {\n  class TranslocoTestingModule {\n    static forRoot(options) {\n      return {\n        ngModule: TranslocoTestingModule,\n        providers: [{\n          provide: TRANSLOCO_TEST_LANGS,\n          useValue: options.langs\n        }, {\n          provide: TRANSLOCO_TEST_OPTIONS,\n          useValue: options\n        }, {\n          provide: APP_INITIALIZER,\n          useFactory: initTranslocoService,\n          deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n          multi: true\n        }, {\n          provide: TRANSLOCO_LOADER,\n          useClass: TestingLoader\n        }, defaultProviders, {\n          provide: TRANSLOCO_CONFIG,\n          useValue: translocoConfig({\n            prodMode: true,\n            missingHandler: {\n              logMissingKey: false\n            },\n            ...options.translocoConfig\n          })\n        }]\n      };\n    }\n\n  }\n\n  TranslocoTestingModule.ɵfac = function TranslocoTestingModule_Factory(t) {\n    return new (t || TranslocoTestingModule)();\n  };\n\n  TranslocoTestingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TranslocoTestingModule\n  });\n  TranslocoTestingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [TranslocoModule]\n  });\n  return TranslocoTestingModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\n\n\nfunction getBrowserLang() {\n  let browserLang = getBrowserCultureLang();\n\n  if (!browserLang || !isBrowser()) {\n    return undefined;\n  }\n\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n\n  return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\n\n\nfunction getBrowserCultureLang() {\n  if (!isBrowser()) {\n    return '';\n  }\n\n  const navigator = window.navigator;\n  let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n  browserCultureLang = browserCultureLang || navigator.language || navigator.browserLanguage || navigator.userLanguage;\n  return browserCultureLang;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TemplateHandler, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, defaultProviders, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeObject, isString, setValue, size, toCamelCase, toNumber, translate, translateObject, translocoConfig, unflatten }; //# sourceMappingURL=ngneat-transloco.mjs.map","map":null,"metadata":{},"sourceType":"module"}