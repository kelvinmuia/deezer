{"ast":null,"code":"import { ElementRef, SimpleChanges } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { debounceTime, fromEvent, Subject, takeUntil } from 'rxjs';\nimport PerfectScrollbar from 'perfect-scrollbar';\nimport { merge } from 'lodash-es';\nimport { ScrollbarGeometry, ScrollbarPosition } from '@fuse/directives/scrollbar/scrollbar.types';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/cdk/platform\";\nimport * as i2 from \"@angular/router\";\n/**\n * Wrapper directive for the Perfect Scrollbar: https://github.com/mdbootstrap/perfect-scrollbar\n */\n\nexport let FuseScrollbarDirective = /*#__PURE__*/(() => {\n  class FuseScrollbarDirective {\n    /**\n     * Constructor\n     */\n    constructor(_elementRef, _platform, _router) {\n      this._elementRef = _elementRef;\n      this._platform = _platform;\n      this._router = _router;\n      /* eslint-enable @typescript-eslint/naming-convention */\n\n      this.fuseScrollbar = true;\n      this._unsubscribeAll = new Subject();\n    } // -----------------------------------------------------------------------------------------------------\n    // @ Accessors\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Getter for _elementRef\n     */\n\n\n    get elementRef() {\n      return this._elementRef;\n    }\n    /**\n     * Getter for _ps\n     */\n\n\n    get ps() {\n      return this._ps;\n    } // -----------------------------------------------------------------------------------------------------\n    // @ Lifecycle hooks\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * On changes\n     *\n     * @param changes\n     */\n\n\n    ngOnChanges(changes) {\n      // Enabled\n      if ('fuseScrollbar' in changes) {\n        // Interpret empty string as 'true'\n        this.fuseScrollbar = coerceBooleanProperty(changes.fuseScrollbar.currentValue); // If enabled, init the directive\n\n        if (this.fuseScrollbar) {\n          this._init();\n        } // Otherwise destroy it\n        else {\n          this._destroy();\n        }\n      } // Scrollbar options\n\n\n      if ('fuseScrollbarOptions' in changes) {\n        // Merge the options\n        this._options = merge({}, this._options, changes.fuseScrollbarOptions.currentValue); // Return if not initialized\n\n        if (!this._ps) {\n          return;\n        } // Destroy and re-init the PerfectScrollbar to update its options\n\n\n        setTimeout(() => {\n          this._destroy();\n        });\n        setTimeout(() => {\n          this._init();\n        });\n      }\n    }\n    /**\n     * On init\n     */\n\n\n    ngOnInit() {\n      // Subscribe to window resize event\n      fromEvent(window, 'resize').pipe(takeUntil(this._unsubscribeAll), debounceTime(150)).subscribe(() => {\n        // Update the PerfectScrollbar\n        this.update();\n      });\n    }\n    /**\n     * On destroy\n     */\n\n\n    ngOnDestroy() {\n      this._destroy(); // Unsubscribe from all subscriptions\n\n\n      this._unsubscribeAll.next(null);\n\n      this._unsubscribeAll.complete();\n    } // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Is enabled\n     */\n\n\n    isEnabled() {\n      return this.fuseScrollbar;\n    }\n    /**\n     * Update the scrollbar\n     */\n\n\n    update() {\n      // Return if not initialized\n      if (!this._ps) {\n        return;\n      } // Update the PerfectScrollbar\n\n\n      this._ps.update();\n    }\n    /**\n     * Destroy the scrollbar\n     */\n\n\n    destroy() {\n      this.ngOnDestroy();\n    }\n    /**\n     * Returns the geometry of the scrollable element\n     *\n     * @param prefix\n     */\n\n\n    geometry(prefix = 'scroll') {\n      return new ScrollbarGeometry(this._elementRef.nativeElement[prefix + 'Left'], this._elementRef.nativeElement[prefix + 'Top'], this._elementRef.nativeElement[prefix + 'Width'], this._elementRef.nativeElement[prefix + 'Height']);\n    }\n    /**\n     * Returns the position of the scrollable element\n     *\n     * @param absolute\n     */\n\n\n    position(absolute = false) {\n      let scrollbarPosition;\n\n      if (!absolute && this._ps) {\n        scrollbarPosition = new ScrollbarPosition(this._ps.reach.x || 0, this._ps.reach.y || 0);\n      } else {\n        scrollbarPosition = new ScrollbarPosition(this._elementRef.nativeElement.scrollLeft, this._elementRef.nativeElement.scrollTop);\n      }\n\n      return scrollbarPosition;\n    }\n    /**\n     * Scroll to\n     *\n     * @param x\n     * @param y\n     * @param speed\n     */\n\n\n    scrollTo(x, y, speed) {\n      if (y == null && speed == null) {\n        this.animateScrolling('scrollTop', x, speed);\n      } else {\n        if (x != null) {\n          this.animateScrolling('scrollLeft', x, speed);\n        }\n\n        if (y != null) {\n          this.animateScrolling('scrollTop', y, speed);\n        }\n      }\n    }\n    /**\n     * Scroll to X\n     *\n     * @param x\n     * @param speed\n     */\n\n\n    scrollToX(x, speed) {\n      this.animateScrolling('scrollLeft', x, speed);\n    }\n    /**\n     * Scroll to Y\n     *\n     * @param y\n     * @param speed\n     */\n\n\n    scrollToY(y, speed) {\n      this.animateScrolling('scrollTop', y, speed);\n    }\n    /**\n     * Scroll to top\n     *\n     * @param offset\n     * @param speed\n     */\n\n\n    scrollToTop(offset = 0, speed) {\n      this.animateScrolling('scrollTop', offset, speed);\n    }\n    /**\n     * Scroll to bottom\n     *\n     * @param offset\n     * @param speed\n     */\n\n\n    scrollToBottom(offset = 0, speed) {\n      const top = this._elementRef.nativeElement.scrollHeight - this._elementRef.nativeElement.clientHeight;\n      this.animateScrolling('scrollTop', top - offset, speed);\n    }\n    /**\n     * Scroll to left\n     *\n     * @param offset\n     * @param speed\n     */\n\n\n    scrollToLeft(offset = 0, speed) {\n      this.animateScrolling('scrollLeft', offset, speed);\n    }\n    /**\n     * Scroll to right\n     *\n     * @param offset\n     * @param speed\n     */\n\n\n    scrollToRight(offset = 0, speed) {\n      const left = this._elementRef.nativeElement.scrollWidth - this._elementRef.nativeElement.clientWidth;\n      this.animateScrolling('scrollLeft', left - offset, speed);\n    }\n    /**\n     * Scroll to element\n     *\n     * @param qs\n     * @param offset\n     * @param ignoreVisible If true, scrollToElement won't happen if element is already inside the current viewport\n     * @param speed\n     */\n\n\n    scrollToElement(qs, offset = 0, ignoreVisible = false, speed) {\n      const element = this._elementRef.nativeElement.querySelector(qs);\n\n      if (!element) {\n        return;\n      }\n\n      const elementPos = element.getBoundingClientRect();\n\n      const scrollerPos = this._elementRef.nativeElement.getBoundingClientRect();\n\n      if (this._elementRef.nativeElement.classList.contains('ps--active-x')) {\n        if (ignoreVisible && elementPos.right <= scrollerPos.right - Math.abs(offset)) {\n          return;\n        }\n\n        const currentPos = this._elementRef.nativeElement['scrollLeft'];\n        const position = elementPos.left - scrollerPos.left + currentPos;\n        this.animateScrolling('scrollLeft', position + offset, speed);\n      }\n\n      if (this._elementRef.nativeElement.classList.contains('ps--active-y')) {\n        if (ignoreVisible && elementPos.bottom <= scrollerPos.bottom - Math.abs(offset)) {\n          return;\n        }\n\n        const currentPos = this._elementRef.nativeElement['scrollTop'];\n        const position = elementPos.top - scrollerPos.top + currentPos;\n        this.animateScrolling('scrollTop', position + offset, speed);\n      }\n    }\n    /**\n     * Animate scrolling\n     *\n     * @param target\n     * @param value\n     * @param speed\n     */\n\n\n    animateScrolling(target, value, speed) {\n      if (this._animation) {\n        window.cancelAnimationFrame(this._animation);\n        this._animation = null;\n      }\n\n      if (!speed || typeof window === 'undefined') {\n        this._elementRef.nativeElement[target] = value;\n      } else if (value !== this._elementRef.nativeElement[target]) {\n        let newValue = 0;\n        let scrollCount = 0;\n        let oldTimestamp = performance.now();\n        let oldValue = this._elementRef.nativeElement[target];\n        const cosParameter = (oldValue - value) / 2;\n\n        const step = newTimestamp => {\n          scrollCount += Math.PI / (speed / (newTimestamp - oldTimestamp));\n          newValue = Math.round(value + cosParameter + cosParameter * Math.cos(scrollCount)); // Only continue animation if scroll position has not changed\n\n          if (this._elementRef.nativeElement[target] === oldValue) {\n            if (scrollCount >= Math.PI) {\n              this.animateScrolling(target, value, 0);\n            } else {\n              this._elementRef.nativeElement[target] = newValue; // On a zoomed out page the resulting offset may differ\n\n              oldValue = this._elementRef.nativeElement[target];\n              oldTimestamp = newTimestamp;\n              this._animation = window.requestAnimationFrame(step);\n            }\n          }\n        };\n\n        window.requestAnimationFrame(step);\n      }\n    } // -----------------------------------------------------------------------------------------------------\n    // @ Private methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Initialize\n     *\n     * @private\n     */\n\n\n    _init() {\n      // Return if already initialized\n      if (this._ps) {\n        return;\n      } // Return if on mobile or not on browser\n\n\n      if (this._platform.ANDROID || this._platform.IOS || !this._platform.isBrowser) {\n        this.fuseScrollbar = false;\n        return;\n      } // Initialize the PerfectScrollbar\n\n\n      this._ps = new PerfectScrollbar(this._elementRef.nativeElement, { ...this._options\n      });\n    }\n    /**\n     * Destroy\n     *\n     * @private\n     */\n\n\n    _destroy() {\n      // Return if not initialized\n      if (!this._ps) {\n        return;\n      } // Destroy the PerfectScrollbar\n\n\n      this._ps.destroy(); // Clean up\n\n\n      this._ps = null;\n    }\n\n  }\n\n  FuseScrollbarDirective.ɵfac = function FuseScrollbarDirective_Factory(t) {\n    return new (t || FuseScrollbarDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.Platform), i0.ɵɵdirectiveInject(i2.Router));\n  };\n\n  FuseScrollbarDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: FuseScrollbarDirective,\n    selectors: [[\"\", \"fuseScrollbar\", \"\"]],\n    inputs: {\n      fuseScrollbar: \"fuseScrollbar\",\n      fuseScrollbarOptions: \"fuseScrollbarOptions\"\n    },\n    exportAs: [\"fuseScrollbar\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return FuseScrollbarDirective;\n})();","map":null,"metadata":{},"sourceType":"module"}